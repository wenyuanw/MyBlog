#  你不知道的JavaScript 上——作用域和闭包

## 作用域是什么

程序编译的三个过程：

1. 分词/语法分析：这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）。
2. 解析/语法分析：这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。
3. 代码生成：将 AST 转换为可执行代码的过程被称为代码生成。



作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。

如果有查找的目的是对变量进行复制，那么就会使用 LHS 查询；

如果目的是获取变量的值，就会使用 RHS 查询。



LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。



不成功的 RHS 引用会导致抛出 **ReferenceError** 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用地目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）。



## 词法作用域

JavaScript 采用的作用域模型是**“词法作用域”**模型。与之相对的是“动态作用域”。

简单地说，词法作用域就是定义在词法阶段的作用域。



作用域查找会在找到第一个匹配的标识符时停止。

在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符"遮蔽"了外部的标识符）。



全局对象会自动成为全局对象（比如浏览器中的 window 对象的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问。

如：window.a

通过这种技术可以访问那些被同盟变量所遮蔽的全局变量。但非全局的变量如果被遮蔽了，无论如何都无法被访问到。



欺骗词法：

eval(...) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。

```js
function foo(str, a) {
	eval(str); // 欺骗
	console.log(a, b);
}
var b = 2;
foo("var b = 3;", 1); // 1,3
```

在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。



with 关键字通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。

with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。



eval(...) 函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而 with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。



eval(...) 和 with 会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。



## 函数作用域和块作用域

**函数作用域**的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上嵌套的作用域中也可以使用）。



函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。

函数是 JavaScript 中最常见的作用域单元。

单函数不是唯一的作用域单元。块作用域指的是变量喝函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 { .. } 内部）。

从 ES3 开始，try/catch 结构在 catch 分句中具有块作用域。



## 提升

包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。



当你看到 var a = 2；时，可能会认为这是一个声明。但 JS 实际上会将其看成两个声明：var a; 和 a = 2;。第一个定义声明是在**编译阶段**进行的。第二个赋值声明会被**留在原地**等待**执行阶段**。

第一个是编译阶段的任务，第二个则是执行阶段的任务。



**只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。**

每个作用域都会进行提升操作。

```js
foo();

function foo() {
	console.log(a); // undefine
	var a = 2;
}
// foo 函数的声明 被提升了，因此第一行的调用可以正常执行
// 这段代码实际上被理解为一下形式：
function foo() {
	var a;
    console.log(a);
    a = 2;
}
foo();
```

**函数声明会被提升，但是函数表达式却不会被提升。**

```js
foo(); // 不是 ReferenceError，而是 TypeError！

var foo = function bar() {
	// ...
}
// 这段程序中的表里标识符 foo() 被提升并分配给所在作用域（这里是全局作用域），因此 foo() 不会导致 
// ReferenceError。但是 foo 此时并没有赋值（如果它是一个函数声明而不是函数表达式，那么就会赋值）
// foo() 由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常。
```

即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用：

```js
foo(); // TypeError
bar(); // ReferenceErrors

var foo = function bar() {
	// ...
}

这个代码片段经过提升后，实际被理解为以下形式：
var foo;

foo(); // TypeError
bar(); // ReferenceErrors

var foo = function() {
	var bar = ...self...
    // ...
}
```

### 函数优先

函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是**函数会首先被提升，然后才是变量。**

```js
// 考虑以下代码：
foo(); // 1

var foo;

function foo() {
	console.log(1);
}

foo = function {
	console.log(2);
}
// 会输出 1 而不是 2 ！这个代码片段会被引擎理解为如下形式：
function foo() {
	console.log(1);
}

foo(); // 1

foo = function {
	console.log(2);
}
// 注意，var foo 尽管出现在 function foo() ... 的声明之前，但它是重复的声明（因此被忽略了），因为函数声明会被提升到普通变量之前。
// 尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。

foo(); // 3

foo = function {
	console.log(1);
}

var foo = function {
	console.log(2);
}

foo = function {
	console.log(3);
}
```

一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下面的代码暗示的那样可以被条件判断所控制：

```js
foo(); // b
var a = true;
if(a){
	function foo() { console.log("a") ;}
} else {
	function foo() { console.log("b") ;}
}
```

因此应该尽可能避免在块内部声明函数。



**声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。**



## 作用域闭包

> 闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包。闭包地创建和使用在你的代码中随处可见。你缺少地是根据你自己的意愿来识别、拥抱和影响闭包的思维环境。



**定义：当函数可以记住并访问所在的词法作用域时，就产生了闭包，及时函数是在当前词法作用域之外执行。**



下面我们来看一段代码，清晰地展示了闭包：

```js
function foo() {
	var a = 2;
	
	function bar() {
		console.log( a );
	}
	
	return bar;
}

var baz = foo();
baz(); // 2 —— 这就是闭包的效果
```

函数 bar( ) 的词法作用域能够访问 foo( ) 的内部作用域。然后我们将 bar( ) 函数本身当作一个值类型进行传递。在这个例子中，我们**将 bar 所引用的函数对象本身当作返回值。** 

在 foo( ) 执行后，其返回值（也就是内部的 bar( ) 函数）赋值给变量 baz 并调用 baz( ) ，实际上知识通过不同的标识符引用调用了内部的函数 bar( )。

bar( ) 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。

在 foo( ) 执行后，通常会期待 foo( ) 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不在使用的内存空间。由于看上去 foo( ) 的内容不会再被使用，所以很自然地会考虑对其进行回收。

而闭包的“神奇”之处正式可以阻止这件事情地发送。事实上内部作用域依然存在，因此没有被回收。

因为 **bar() 本身在使用这个作用域。**

由于 bar( ) 的声明位置，它拥有涵盖 foo( ) 内部作用域的闭包，使得该作用域能够一直存活，以供 bar( ) 在之后任何时间进行调用。

**bar( ) 依然持有对该作用域的引用，而这个引用就叫做闭包。**

因此，在几微秒之后变量 baz 被实际调用（调用内部函数 bar ），不出意料它可以访问定义域时的词法作用域，因此它也可以如预期般访问变量 a 。

这个函数在定义时地词法作用域以外地地方被调用。**闭包使得函数可以继续访问定义时的词法作用域。**



当然，**无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。**

```js
function foo() {
	var a = 2;
	
	function baz() {
		console.log( a ); // 2
	}
	
	bar(baz);
}

function bar(fn) {
	fn(); // 这就是闭包！
}
```

把内部函数 baz 传递给 bar ，当调用这个内部函数时（现在叫做 fn ），它涵盖的 foo( ) 内部作用域的闭包就可以观察到了，因为它能够访问 a。



传递函数也可以是间接的：

```js
var fn;

function foo() {
	var a = 2;
    function baz() {
		console.log( a );
    }
    fn = baz; // 将 baz 分配给全局变量
}

function bar() {
	fn(); // 这就是闭包！
}

foo();
bar(); // 2
```

无论通过任何手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。



一个常见的闭包：

```js
function wait(message) {
	setTimeout( function timer() {
		console.log(message);
    }, 1000);
}
wait("Hello, closure!");
```

将一个内部函数（名为 timer ）传递给 setTimeout(..)。timer 具有涵盖 wait(..) 作用域的闭包，因此还保有对变量 message 的引用。



本质上无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Worker 或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包。



### 循环和闭包

要说明闭包，for 循环时最常见的例子。

```js
for (var i = 1; i <= 5; i++){
	setTimeout( function timer() {
		console.log( i );
	}, i*1000);
}
```

正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次，每次一个。

但实际上，这段代码在运行时会以每秒一次的频率输出五次 6。

**延迟函数的回调会在循环结束时才执行。**

事实上，当定时器运行时即使每个迭代中执行的是 setTimeout(.., 0)，所有的回调函数依然实在循环结束后才会被执行，因此会每次输出一个6出来。

> 上述代码的缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个 i 的副本。但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i。



IIFE 会通过声明并立即执行一个函数来创建作用域。所以以下代码能解决问题吗？

```js
for (var i = 1; i <= 5; i++){
	(function() {
        setTimeout(function timer() {
			console.log(i);
        }, i*1000);
    })();
}
```

答案是不行的。

的确每个延迟函数都会将 IIFE 在每次迭代中创建的作用域封闭起来。

如果作用域是空的，那么仅仅将它们进行封闭式不够的。仔细看一下，我们的 IIFE 知识一个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。

它需要有自己的变量，用来在每个迭代中储存 i 的值。



解决代码：

```js
for (var i = 1; i <= 5; i++){
	(function(j) {
        setTimeout(function timer() {
			console.log(j);
        }, j*1000);
    })(i);
}
```

**在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。**



我们使用 IIFE 在每次迭代时都创建一个新的作用域。换句话说，每次迭代我们都需要一个块作用域。

**let** 声明，可以用来劫持块作用域，并且在这个块作用域中声明一个变量。

本质上这是将一个块转换成一个可以被关闭的作用域。因此下面这段代码可以正常运行。

```js
for (var i=1; i<=5; i++) {
	let j=i; // 闭包的块作用域
    setTimeout(function timer() {
			console.log(j);
    }, j*1000);
}
```

for 循环头部的 let 声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。

```js
for (let i=1; i<=5; i++) {
    setTimeout(function timer() {
			console.log(i);
    }, i*1000);
}
```

这就是**块作用域+闭包**的效果。